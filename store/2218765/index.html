<p>linux 对于各种可执行文件的识别:</p>

<p>(1)a.out(在fs/binfmt_aout.c中)：这是为了支持原来风格的Linux二进制文件。它的存在
主要是为了满足一些系统的向后兼容的需要，但是基本上a.out已经光荣退役了。</p>

<p>(2) ELF(在fs/binfmt_elf.c中)：目前是Linux默认的二进制文件格式。该格式在可执行文
件和共享库中都广泛使用。最新的Linux系统 (例如Red Hat 9)一般只预装了ELF二进制文件
解释器，但是特殊情况下要决定加载a.out二进制文件，那么系统也通过模块的方式，对它
提供支持。虽然ELF被作为惯用的Linux本地格式，但也和其它格式一样使用同一个加载处理
程序。</p>

<p>(3)EM86(在fs/binfmt_em86.c中)：允许在Alpha机器上运行Intel的Linux二进制文件，仿佛
它们就是Alpha的本地二进制文件。</p>

<p>(4) Java(在fs/binfmt_java.c中)：可以不必每次都定义Java字节码的解释程序就可以执行
Java的.class文件。这种机制和脚本中使用的机制类似，通过把.class文件的文件名作为参
数传递，处理程序返回执行整型字节码的解释程序。从用户的观点来看，Java二进制文件是
作为本地可执行文件处理的。</p>

<p>(5)misc(在fs/binfmt_misc.c中)：这是最明智地使用二进制处理程序的方法，这个处理程
序通过内嵌的特征数字或者文件名后缀可以识别出各种二进制格式，不过最优秀的特性是它
可以在运行期配置，而不是只能在编译期配置。因此，只要遵循其规则，就可以快速的增加
对新二进制文件的支持，而不用重新编译内核，也无须重新启动机器。Linux源程序文件中
的注释建议最终使用它来取代Java和EM86二进制处理程序。</p>

<p>(6)脚本(在fs/binfmt_script.c中)：对于shell脚本、Perl脚本等提供支持。宽松一点地说
，所有前面两个字符是“#!”的可执行文件，都归由这个二进制处理程序进行处理。</p>

<p>这些Linux支持的二进制格式，可以在内核编译链接的时候直接建立在内核之中，也可以在
内核运行的时候作为模块来加载。内核保存了支持的二进制格式解释程序的列表，当试图执
行一个文件的时候，每一个二进制格式都会被依次尝试，直到判断出可识别的对应的二进制
格式为止。</p>

<p>这里的我关注的是#!这种方式. 看了一下binfmt_script 看到对于#! 进行检查. 并把这个
#!到换行符之间的内容去掉两边的空格并运行.这是内核层面的识别机制. #! 就是一个magic 数</p>
