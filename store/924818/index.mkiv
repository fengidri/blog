%title:linux下动态链接实现原理
%class: compile
\section{PIC}
上一次研究这个问题还是在研究uboot的时候.
这个东西的应用我所知有两个: 一是Bootloader, 另一个就是动态库.
生成共享库的时候要求所有的目标文件都是目标无关的. 但是在32位上好像不
用显式指定.

不同于静态链接动态链接时有以下的要求:
\startitemize
\item  在动态链接的时候是不能修改库的代码的. 因为库文件作用于多个独立的进程的.
\item  不允许对可执行文件的代码段进行加载时符号重定位
\stopitemize

动态连接使得大部分的连接过程延迟,直到程序开始运行。这种做法做提供了许多其它方法难以实现的优点：
\startitemize
\item  动态连接库比静态连接库更容易创建。
\item  动态连接库比静态连接库更容易更新。
\item  动态连接库容许程序在运行时装载和卸载例程，这是其它方式很难提供的一个功能。
\stopitemize



\section{关键字}
\startitemize
\item  {PIC:}  位置无关代码(Position-Independent Code, PIC)
\item {GOT:} 全局偏移量表(Global Offset Table, GOT).
\item {lazy binding:} 延迟绑定.
\item{PLT:} 过程链接表(Procedure Linkage Table, PLT)
\stopitemize

\section{基础知识与技巧}
\startitemize
\item  x86 上函数调用只用到相对地址
\item 访问数据需要绝对地址
\item  x86 下没有指令可以取当前 IP 的值. 所以通过实现函数调用把返回地址压到栈上，再读栈上的值就可以获得下一条指令的地址了. (x86_64下就不用这么麻烦)
\stopitemize

\section{加载时符号重定位}
在实现静态链接的问题上
Linux 下 ELF 主要支持两种方式：加载时符号重定位及地址无关代码.
加载时重定位实际上是一个重新修改动态库代码的过程. 这其实是不合符我们的要求的.
这里面还有一个问题, 由于\bold{不允许对可执行文件的代码段进行加载时符号重定位}
所以不能在加载时修改代码段. 所以如果代码中要访问
一个数据, 那么在静态链接的过程中这个工作就应该已经完成了. 但是实际上是完成不了的.
所以做法是在静态连接的过程中在\bold{当前执行文件}的数据段里分配相应的空间.
在加载动态库的时候, 重定向\bold{动态库} 中对于符号的访问.

另一个是关于函数的调用的问题. 这个过程有涉及到了lazy binding. 下面再说.


\section{PIC 模块内符号的访问}
符号有两类数据与函数. 之前说过函数使用相对地址没有关系. 那问题只有一个对数据如何进行访问.
这里的技巧在于数据段与代码的相对位置是固定的. 也就是说我们有相对位置.
在程序编译的时候如果要访问一个相对位置为A的数据. 我们只要得到当前的IP 地址再加上A 就可以
访问了.

\section{PIC 模块间数据的访问}
重定位解决的是符号引用的问题.这些符号又可以分成数据与函数两种.

GOT 是在数据段与代码段之间用于对于数据进行访问. 这个数据在动态库加载后由动态加载器进行初始化.

GOT和调用它的代码是在同一个ELF文件中，因此不管程序装载到地方，GOT的相对位置不会改变，
所有代码可以通相对地址来定位GOT，把GOT的地址装到寄存器，然后装载GOT的内容，它指向一个静态数据。
如果一个库没有引用静态数据，可以不包含GOT，但是事实上，所有的库都包含了一个GOT。

为了支持动态连接，每个ELF共享库和每个使用共享库的可执行文件都有一个PLT(Procedure Linkage Table)。
同GOT访问数据的方法类似，PLT提供了一个间接访问函数的方法。
PLT支持懒惰模式（lazy evaluation）, 即直到函数首次被调用才解析。
考虑到PLT项比GOT项要多得多（在一个通用的C库里面有近600个）,而大部分的例程根本不会被调用，
所以使用惰性模式可以节省启动时间和加速整个程序。

这里有必要说明一下调用关系. 以可执行文件A为中心, 可能还有多个动态库B,C,D.
A 中对于B, C, D的符号引用是通过A中的GOT 数据实现. 另一方面B, C, D之间也有符号访问. 所以B, C, D也有自己
的GOT 数据.


\section{延迟加载}
我们知道，动态库是在程序启动的时候加载进来的，加载后，动态链接器需要对其作一系列的初始化，如符号重定位，这些工作是比较费时的，
特别是对函数的重定位，那么我们能不能把对函数的重定位延迟进行呢？这个改进是很有意义的，毕竟很多时候，一个动态库里可能包含很多的全局函数，
但是我们往往可能只用到了其中一小部分而已，完全没必要把那些没用到的函数也过早进行重定位，具体来说，就是应该等到第一次发生对该函数的调用时才进行符号绑定 -- 此谓之延迟绑定。

延迟绑定的实现步骤如下：

建立一个 GOT.PLT 表，该表用来放全局函数的实际地址，但最开始时，该里面放的不是真实的地址而是一个跳转，接下来会讲。

对每一个全局函数，链接器生成一个与之相对应的影子函数，如 fun@plt。

所有对 fun 的调用，都换成对 fun@plt 的调用， 长成如下样子：
\starttyping
fun@plt:
    jmp *(fun@got.plt)
    push index
    jmp _init
\stoptyping

其中第一条指令直接从 got.plt 中去拿真实的函数地址，如果已经之前已经发生过调用，got.plt 就已经保存了真实的地址，
如果是第一次调用，则 got.plt 中放的是 fun@plt 中的第二条指令，这就使得当执行第一次调用时，fun@plt中的第一条指令其实什么事也没做，
直接继续往下执行，第二条指令的作用是把当前要调用的函数在 got.plt 中的编号作为参数传给 init()，
而 init() 这个函数则用于把 fun 进行重定位，然后把结果写入到 got.plt 相应的地方，最后直接跳过去该函数。



\section{加载过程}
\subsection{启动动态连接器}
当操作系统运行程序， 注意可执行文件中的INTERP节， 它所指的解释程序就是动态连接器：ld.so(在linux 64位上是: ld-linux-x86-64.so.2).
ld.so本身就是ELF格式的共享库。操作系统启动程序的时候，首先将动态连接器映射到一个合适的地址，
然后传递一个连接器所需要的辅助向量（辅助）信息到堆栈，最后启动ld.so。

辅助向量（辅助信息）包括：
\startitemize
\item  AT_PHDR, AT_PHENT 和 AT_PHNUM：程序文件头的地址， 程序头中入口项的大小和数目。
入口项描叙了文件的段信息。如果系统还没有把程序映射到内存，那么就会有一个AT_EXECFD入口项，它包含了程序文件打开后的文件描叙符。
\item  AT_ENTRY：程序开始地址，动态连接器在初始化完毕后就会跳到这个地方。
\item  AT_BASE：动态连接器被装载的地址。
\stopitemize

此时，ld.so 开始部分的自引导代码首先查找自己的GOT，GOT的第一个入口项指向ld.so文件中的dynamic段。
通过dynamic段，连接器可以找到自己的重定向入口，在自己的数据段中重定向指针，解析装载其它符号的基本例程的代码位置。
（linux ld.so 用 _dt_ 给这些基本例程取名，使用特定的代码会去寻找以 _dt_ 开始的符号，然后将它们解析）

然后，连接器用程序符号表指针和连接器符号表指针来初始化符号表链。
从概念上说，程序和装载到进程中的所有库共享一个符号表，与其在运行时将所有的符号表合并，
不如由连接器维护一个每个文件符号表的链表。
每个文件包含一个哈希表，通过一些哈希头和每个头对应的哈希链表，
连接器只要计算符号的哈希值一次，就可以迅速查到所需的符号，加速符号了查询.

\subsection{库的查找}

一旦连接器完成了自己的初始化工作，就查找程序所需要的库的名字。
程序头中有一个指针指向dynamic段，它包含了动态连接的信息，dynamic段中的DT_STRTAB指向一个字符表，
而其中的DT_NEEDED包含了一个相对于字符表的偏移，指向所需要的库名。

对于每一个库，连接器首先查找库文件位置，从本质上说是一个相当复杂的过程。
DT_NEEDED所描叙的库文件名一般类似libXt.so.6 (Xt开发包, 版本6)，库文件可能在任意的库文件目录中，还也可能有重名的文件。

连接器查找下列几个地方：
\startitemize
\item  首先查看 .dynamic 段是否包含了一个叫DT_RPATH的项（它是一个以冒号分隔的库文件搜索目录列表）。
            这个项是在程序被连接器连接时（这里所说的不是动态连接器 ld.so， 而是所谓的静态连接器 ld） ，
            由命令行开关或者环境变量添加上去的。
            它常应用于子系统中，比如像数据库应用，我们要装载一些程序集合以及支持库到一个目录中去的时候。
\item  查看是否存在环境变量 LD_LIBRARY_PATH（它是一个以冒号分隔的库文件搜索目录列表）。
            这个项可以帮助开发者建立一个新版本的库，把他的路径添加到LD_LIBRARY_PATH中，
            把它和现存的可连接程序一同使用，用来测试新的库，
            or equally well to instrument the behavior of the program.
            (It skips this step if the program is set-uid, for security reasons.)
\item  连接器查看库高速缓存文件 /etc/ld.so.conf ，它包含了库名和路径的一个对应列表，如果库名存在，连接器就使用它对应的路径，
              用这个查找方法能够找到大部分的库（文件名不需要和要求完全符合，这点可以参考接下来的“库的版本”）。
\item  如果上叙的查找都失败，连接器就查找默认路径 /usr/lib ,如果库文件依旧没有找到，则显示一个错误然后退出。
\stopitemize

连接器找到了库文件后，先打开它，然后读取ELF头，找到指向各个段的指针
（to find the program header which in turn points to the file’s segments including the dynamic segment，应该还有更好的翻译方式）。
连接器为库的代码段和数据段分配空间并映射到内存，随后是bss（不分配空间）。
通过库的 .dynamic 段，连接器添加这个库的符号表到符号表链，如果库所依赖的其它库没有装载的话，则添加那个库到装载队列中。

完成这个过程后，所有的库都已经被映射，loader在逻辑上拥有了一个全局的符号表，它是全部程序和被映射库的符号表的联合。

\subsection{共享库的初始化}

现在loader再次访问每个库，处理库的重定向入口，填充库的GOT，将库的数据段进行重定位。x86下的装载时重定位类型包括：
\startitemize
\item    {R_386_GLOB_DAT}用来初始化GOT项，符号地址定义在另外一个库中。
\item    {R_386_32}      非GOT项，符号地址定义在另外一个库中。（和上面的区别是什么？）
\item    {R_386_RELATIVE}重定向数据，比较典型的是一个字符串的指针或者一个局部定义的静态数据。
\item    {R_386_JMP_SLOT}用来初始化PLT的GOT项}后面有详解。
\stopitemize

如果一个库有 .init 节，则它作为库的特定初始化例程被 loader 调用，如C＋＋的静态构造器；
同样，程序在退出的时候要运行 .fini 节的例程。
（上叙的工作不是由主程序main来完成的，而是程序自启动代码来处理，在linux中这些代码在 ld.so 中的_glibc_start_main 中）。
当上面的工作完成以后，所有的库都被完全装载并准备运行，loader最终调用程序的开始地址（AT_ENTRY），程序开始执行。

\section{静态初始化}

如果一个程序引用了一个定义在共享库的全局变量，由于程序的数据地址必须在连接时确定，连接器必须为之创建一个变量的拷贝，如Figure4。
由于动态连接器可以通过一个GOT指针来修正这些地址，一般不会出现什么问题。
但是，如果共享库初始化了这个变量，那么程序中将无法知道。
为了解决这个问题，连接器在程序的重定位表中设置一个类型为 R_386_COPY
(否则只包含 R_386_JMP_SLOT,R_386_GLOB_DAT, R_386_32, 和R_386_RELATIVE )的入口项，指向程序中变量拷贝的地址，
然后告诉动态连接器从共享库重将变量的初始化值拷贝过来。

虽然这个特性在某些类型的代码中是很基本的，但是在实际中出现得确非常少。
由于只作用于单个数据，所以是个权宜之计。但是被初始化的通常是函数或数据的指针，所以这种折衷就足够了。









\section{参考}
\startitemize
\item  \goto{linux下动态链接实现原理}{http://www.cnblogs.com/catch/p/3857964.html}
\item  \goto{动态连接和装载}{http://blog.csdn.net/baqiao10/article/details/288606}
\item  \bold{Computer System A Progarammer's Perspecitve}
\stopitemize