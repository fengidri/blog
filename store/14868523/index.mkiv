%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Title:过程尾部调用
%Class: compile
%Post:1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{介绍}

过程尾部调用是一种优化. 这种优化会加快程序的调用过程. 另一种优化尾递归
是尾递归的特殊形式.

\section{过程尾部调用}
形如代码:
\starttyping
int fun1()
{
    ....
    fun2();
}
\stoptyping
在函数fun1的结尾调用了函数fun2, 那么在调用fun2 之后其实是没有必要
再回到fun1 的, 因为在fun1 中没有其它的工作了. 那么可以使用 jump 来
代替 call 指令. 对于当前的stack 可以直接使用, 带不用再使用新的stack.
对于当前的现场也没有必然进行保留. 这对一性能的提高, 内存使用的降低都是
很好的.

\section{尾递归}
我们知道在很多时候不应该使用递归在实现, 因为如果递归的层次再多了, 那么就
可能会出现内存不足的情况. 但是如果递归合符尾递归的要求, 在函数的
结尾使用尾递归优化, 那样的情况下, 递归的内存使用就不是问题了.

尾调用的重要性在于它可以不在调用栈上面添加一个新的堆栈帧——而是更新它，
如同迭代一般。尾递归因而具有两个特征：
\startitemize
\item  调用自身函数(Self-called)；
\item  计算仅占用常量栈空间(Stack Space)。
\stopitemize

\section{函数的调用过程}
一般情况下, 对于函数的调用如下:
\startitemize
\item  按一定顺序(从左之右，或从右之左)所参数压入堆栈中
\item  把函数执行完后的返回地址压入堆栈，控制转到被调用函数(比如运行call指令)
\item  被调用者把返回值存入到寄存器或堆栈中(一般是寄存器)
\item  被调用者根椐堆栈中保存的返回地址，返回控制给调用者(可选清除参数)
\item  调用者清除参数(可选，如果4步中被调者清除参数)
\stopitemize

假定函数调用如下 f - g - h.
g调用h 的形式合符尾部调用的要求.

那么在调用的过程中, 在g - h 的过程中, 要修改
stack 换成 h 的参数, 再jump 到 h, 对于h 来说, 就如同是f - h.

而在调用结束之后, 直接回到f.


\section{应用}
\subsection{netfilter}
一个比较有名的应用就是linux kernel 中网络协议中善于netfilter 的实现.

在netfilter 的实现中有一个问题, 如果用户禁用了netfilter,  那么钩子函数也要每一次都运行吗?
这种细节的问题, 在实现上使用了一种比较麻烦的方式. 把要插入钩子的函数一分为二,
钩子函数在前一个函数的最尾部. 这样在编译的过程中, 如果用户禁用了netfilter,
编译器会对于这部分代码进行优化.

早期的实现中使用内联函数的优化方式, 现在的一部分实现是使用尾部优化的方式.
\subsection{函数式}
一般来说，尾调用消除是可选的。
然而，在函数编程语言中，语言标准通常会要求虚拟机实现尾调用消除，
这让程序员可以用递归取代循环而不丧失性能。

在erlang中变量不能被修改，因而也没有循环控制语句，
靠迭代来实现，这依赖于尾递归优化。
这样也使得erlang的每个进程特别轻量，只需要占用很少的堆空间。




\goto{尾调用}{http://zh.wikipedia.org/wiki/\%E5\%B0\%BE\%E8\%B0\%83\%E7\%94\%A8}