<p></p>

<h3>介绍</h3>
<p>过程尾部调用是一种优化. 这种优化会加快程序的调用过程. 另一种优化尾递归
是尾递归的特殊形式.</p>

<h3>过程尾部调用</h3>
<p>形如代码:
<pre>
int fun1()
{
    ....
    fun2();
}
</pre>

在函数fun1的结尾调用了函数fun2, 那么在调用fun2 之后其实是没有必要
再回到fun1 的, 因为在fun1 中没有其它的工作了. 那么可以使用 jump 来
代替 call 指令. 对于当前的stack 可以直接使用, 带不用再使用新的stack.
对于当前的现场也没有必然进行保留. 这对一性能的提高, 内存使用的降低都是
很好的.</p>

<h3>尾递归</h3>
<p>我们知道在很多时候不应该使用递归在实现, 因为如果递归的层次再多了, 那么就
可能会出现内存不足的情况. 但是如果递归合符尾递归的要求, 在函数的
结尾使用尾递归优化, 那样的情况下, 递归的内存使用就不是问题了.</p>

<p>尾调用的重要性在于它可以不在调用栈上面添加一个新的堆栈帧——而是更新它，
如同迭代一般。尾递归因而具有两个特征：

    <ul>

        <li>调用自身函数(Self-called)；

        <li>计算仅占用常量栈空间(Stack Space)。
    </ul></p>

<h3>函数的调用过程</h3>
<p>一般情况下, 对于函数的调用如下:

    <ul>

        <li>按一定顺序(从左之右，或从右之左)所参数压入堆栈中

        <li>把函数执行完后的返回地址压入堆栈，控制转到被调用函数(比如运行call指令)

        <li>被调用者把返回值存入到寄存器或堆栈中(一般是寄存器)

        <li>被调用者根椐堆栈中保存的返回地址，返回控制给调用者(可选清除参数)

        <li>调用者清除参数(可选，如果4步中被调者清除参数)
    </ul></p>

<p>假定函数调用如下 f - g - h.
g调用h 的形式合符尾部调用的要求.</p>

<p>那么在调用的过程中, 在g - h 的过程中, 要修改
stack 换成 h 的参数, 再jump 到 h, 对于h 来说, 就如同是f - h.</p>

<p>而在调用结束之后, 直接回到f.</p>

<h3>应用</h3>
<p></p>

<h4>netfilter</h4>
<p>一个比较有名的应用就是linux kernel 中网络协议中善于netfilter 的实现.</p>

<p>在netfilter 的实现中有一个问题, 如果用户禁用了netfilter, 那么钩子函数也要每一次都运行吗?
这种细节的问题, 在实现上使用了一种比较麻烦的方式. 把要插入钩子的函数一分为二,
钩子函数在前一个函数的最尾部. 这样在编译的过程中, 如果用户禁用了netfilter,
编译器会对于这部分代码进行优化.</p>

<p>早期的实现中使用内联函数的优化方式, 现在的一部分实现是使用尾部优化的方式.</p>

<h4>函数式</h4>
<p>一般来说，尾调用消除是可选的。
然而，在函数编程语言中，语言标准通常会要求虚拟机实现尾调用消除，
这让程序员可以用递归取代循环而不丧失性能。</p>

<p>在erlang中变量不能被修改，因而也没有循环控制语句，
靠迭代来实现，这依赖于尾递归优化。
这样也使得erlang的每个进程特别轻量，只需要占用很少的堆空间。</p>

<p>&nbsp;<a href=http://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8 >尾调用</a>&nbsp;</p>
