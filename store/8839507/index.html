<p></p>

<p> Linux无线驱动接口有两种标准接口，wext（Wireless Extensions无线扩展接口）和nl80211接口。</p>

<p> 在linux-2.6.18版本之前，linux内核代码中并没有提供无线驱动接口以及无线驱动协议栈。
 wext是由开发者Jean Tourrilhes （惠普实验室软件工程师）定义的一套供用户层软件访问无线驱动以及驱动事件通知用户层的接口。
 当时无线驱动的协议栈软件比较多，如开源项目hostap，madwifi，mac80211，ieee80211协议栈以及无线芯片厂商自己实现的协议栈，基本都使用wext接口。
 wext接口也逐渐成为一套标准的接口。
 在linux-2.6.18版本，wext和mac80211协议栈并入内核，成为linux kernel的一部分。
 wext接口随着802.11协议从802.11，802.11b，802.11a/g的发展，其API也不断增加，伴随着就是其wext的版本号不断变化。</p>

<p> wext的接口实现上，应用层采用ioctl方式访问驱动，设置无线参数或者获取无线参数，配置无线驱动进行联网操作。
 无线驱动事件到应用层的传递采用的netlink socket技术，一种netlink route消息技术。这也是很多其他类型的驱动标准的实现方法。
 但在linux-2.6.25（记得不是很清楚了，懒得确定了）之后，wext API接口版本停止在V22就不再进行更新了。而替代其的是nl80211接口。</p>

<p> nl80211接口其实在linux-2.6.18并入wext和mac80211协议栈的时候已经提供，但当时的功能还不完整，而且应用层的软件还是都使用WEXT接口，
 驱动基本不使用nl80211接口实现（除了基于mac80211协议栈的驱动）。
 nl80211接口是由开发者Johannes Berg实现的，他也是cfg80211（无线协议栈配置接口，在无线驱动接口和mac80211之间的接口）和mac80211的维护者。
 无论是用户层访问驱动还是驱动事件通知应用层，nl80211接口都采用的netlink技术。</p>

<p> nl80211接口逐渐替代wext接口的原因主要是使用netlink技术在应用层和内核层数据交换上相比ioctl方式具有优势，
 具体的比较见&nbsp;<a href=http://blog.fengidri.me/?id=8840254 >点击打开链接</a>&nbsp;（转载的一篇文章，写得非常清楚），而且很多其他之前使用ioctl的驱动也逐渐采用了netlink方式。
 再一个原因就是802.11协议的发展，随着802.11n协议以及P2P，WPS无线规范的加入，协议的很多功能可以在应用层实现，增加了很多应用层与驱动层间的API接口和事件。
 WEXT接口不方便功能扩展的缺点，nl80211可以完全支持wext的所有功能，又可以在不修改内核的情况下增加命令字和事件。
 无线驱动接口从wext发展到nl80211也就顺理成章。</p>

<p> 目前linux内核中无线驱动的实现大部分基于mac80211协议栈，无线驱动接口也是可选的，可以使用任意一种，也可以同时使用。
 wpa_supplicant编译时，则根据无线驱动的接口使用情况，确定采用哪种配置接口。
 nl80211除了确定应用层和驱动层的交互标准外，对802.11协议的实现功能划分产生影响。
 目前通常的802.11 SME功能（无线服务管理实体，即协议栈功能）在驱动或者芯片固件中实现，nl802.11的作者希望在应用层实现更多的协议功能。
 wpa_supplicant（包括hostapd）除了实现WPA认证，P2P，WPS的大部分功能外，它还实现了SME功能，在这种功能划分模式下，无线驱动基本上只需要实现配置硬件和数据收发功能。</p>

<p> linux系统下wpa_supplicant的Driver Event模块和Driver I/F模块（这两者实现是在一个文件，初始化在一个函数，划分成两个模块只是设计理解更清晰）的分析也分wext部分和nl80211部分。</p>

<p> &nbsp;<a href=http://blog.csdn.net/dickjtk/article/details/11862815 >linux无线驱动接口简介</a>&nbsp;</p>
